
#############
=============
# current setup...
# locking inbound to root execution
# locking inbound to specific uid/gid
=============

 root only binds

  sysctl -w net.ipv4.ip_unprivileged_port_start=0 # off
  sysctl -w net.ipv4.ip_unprivileged_port_start=32768 # on

* creates a race condition on any system change
^ ephemeral set it up once and leave it or reboot
^ assumes firewall rules only open ports below 32768

vs

 input conntrack

         new - creates the row cant check skuid skgid
 established - queries for row can  check skuid skgid

* conntrack automatic replies have no uid gid
^ hangs inbound and outbound connections spamming conntrack

=============
#############

#############

-------------

 table <family> <name> {
  chain <name> {
   type <type> hook <hook> priority 0
   policy {accept,drop}
   <match> <target>
  }
 }

-------------

 nft add table <family> <table>
 nft flush table <family> <table>
 nft delete table <family> <table>

 nft add chain <family> <table> <chain> { type <type> hook <hook> priority 0 ; policy {accept,drop} ; }
 nft add chain <family> <table> <chain> { policy drop ; }
 nft flush chain <family> <table> <chain>
 nft delete chain <family> <table> <chain>

-------------

  [table]

 <family> - <address types>
   netdev - match interface
      arp - match arp
   bridge - match arparp
       ip - match v4
      ip6 - match v6
     inet - match v4 v6

-------------

 [chain]

      <type> - 
      filter - 
         nat - 
       route - 

      <hook> -
     ingress
  prerouting
       input
     forward
      output
 postrouting
      egress

-------------

 [family] - <hook>
   <type> -
           ---------------------------------------------------------------------------
           | ingress | prerouting | input  | forward | output | postrouting | egress |
  (netdev) ---------------------------------------------------------------------------
    filter | yes     | no         | no     | no      | no     | no          | yes    |
       nat | no      | no         | no     | no      | no     | no          | no     |
     route | no      | no         | no     | no      | no     | no          | no     |
     (arp) --------------------------------------------------------------------------|
    filter | no      | no         | yes    | no      | yes    | no          | no     |
       nat | no      | no         | no     | no      | no     | no          | no     |
     route | no      | no         | no     | no      | no     | no          | no     |
  (bridge) --------------------------------------------------------------------------|
    filter | no      | yes        | yes    | yes     | yes    | yes         | no     |
       nat | no      | no         | no     | no      | no     | no          | no     |
     route | no      | no         | no     | no      | no     | no          | no     |
      (ip) --------------------------------------------------------------------------|
    filter | yes     | yes        | yes    | yes     | yes    | yes         | yes    |
       nat | no      | yes        | yes    | no      | yes    | yes         | no     |
     route | no      | no         | no     | no      | yes    | no          | no     |
     (ip6) --------------------------------------------------------------------------|
    filter | yes     | yes        | yes    | yes     | yes    | yes         | yes    |
       nat | no      | yes        | yes    | no      | yes    | yes         | no     |
     route | no      | no         | no     | no      | yes    | no          | no     |
    (inet) --------------------------------------------------------------------------|
    filter | yes     | yes        | yes    | yes     | yes    | yes         | no     |
       nat | no      | yes        | yes    | no      | yes    | yes         | no     |
     route | no      | no         | no     | no      | yes    | no          | no     |
           --------------------------------------------------------------------------|
 
 [taget]

  accept
  drop
  reject

  return
  continue
  jump <chain> (comes back)
  goto <chain> (doesnt come back)

  limit
  counter
  log

  queue

  redirect to <port>
  dnat to <addr>
  snat to <addr>
  masquerade {random,fully-random,persistent}
  notrack
  set

  dup to 127.0.0.2
  dup to 127.0.0.2 device lo

-------------

#############

 tables define the type of src/dst address family to match on
 chains with hooks are entry points for packets to be filtered
 chains without hooks can be jumped into and out of

#############

 create any table and chain structures you feel like
 adding a hook to a chain creates the flow of packets
 multiple hooks of the same type flow based on priority

#############

 everything originates from interface as a match IN= || OUT=
 single routing table vs routing table per interface (CONFIG_IP_MULTIPLE_TABLES)
 traffic either flows in/out of the same interface or requires a routing lookup
 forwarding is used to filter which interfaces are allowed to talk to each other
 eg IN=eth0 DST=some.address < - global routing table or eth0 routing table lookup searches for DST= then sets OUT=interface

#############

 dnat client uses whatever interface= was for the original request
 dnat client output changes the src/dst addr and port before it hits the filter chain
 dnat client input  changes the src/dst addr and port back to the original request before it hits the filter chain

#############

 iif vs iifname

 all interfaces when added to the box get an index

 iif matches on the index < - isnt persistent through interface deletion and creation but uses less resources

 iifname matches on the interface name string using more resources but persisteing through none existing interfaces

 iifname can take a wildcard value to match multiple interface eth* wlan*

#############

 cat /proc/net/nf_conntrack

 conntrack-tools < - can manally update conntrack table from cli

#############

nftables:

size vs speed < - tends to pop up everywhere

conditional branches that force itteration of a list
 single massive list reduces code size
 smaller overlapping lists with more branches reduce computation time whilst increasing code size

length of chain from input or output to matching an implicit rule for the packet

tune any setup to reduce the chain length for the higest frequency packet types any exceptions can be handled after the fact

^ white/blacklist logic
  list size of banned ips vs list size of allowed ips
  rebalancing rules to match the smaller list increases throughput

* how rules are written will have a huge impact on performance when scaled < - hoping thats self explaintory ?

#############

#############

 [nftrace]

 iifname lo meta nftrace set 1

 iifname lo ip protocol tcp meta nftrace set 1
 iifname lo ip protocol udp meta nftrace set 1

 nft monitor trace

#############

 [counters] (define in table not chain)

 nft list counters
 nft list counter <family> <table> <counter>

 nft reset counters
 nft reset counter <type> <table> <name>

 counter name <name> { }
 counter name <name> { comment "informational text" }

#############

 [sets] (define in table not chain)

 nft list sets
 nft list set <family> <table> <set>

        type - ipv4_addr,ipv6_addr,ether_addr,inet_proto,inet_service,mark,ifname
      typeof - <match>
     timeout - 1 s/m/h/d
       flags - constant,dynamic,interval,timeout
 gc-interval - 1 s/m/h/d
    elements - elements={<value>,<value>}
        size - 65534
      policy - {performance,memory}
     counter - 
 
 set my_set { typeof ip saddr . ip dport ; flags dynamic,timeout ; timeout 300s ; counter ; }

 <type> . <type> @my_set drop
 <type> . <type> @my_set accept

 set add    <type> . <type> timeout <timeout> @my_set # doesnt update timeout
 set update <type> . <type> timeout <timeout> @my_set # does update timeout

 nft add element <family> <table> <set> { <type> . <type> ; timeout <timeout> ; }
 nft delete element <family> <table> <set> { <type> . <type> ; timeout <timeout> ; }

 * my_set { typeof ip daddr . tcp dport ; } < - creates type ipv4_addr
 * set add ip saddr . tcp sport @my_set < - allows adding any match of the type created...

#############

 [conntrack limit]

  ct count      <number> accept
  ct count over <number> drop

  tcp dport 80 ct count 30 accept # per service
  tcp dport 80 meter connlimit { ip saddr ct count 3 } accept # per user on service

 [rate limit]

  limit rate [over] <value> <unit> [burst <value> <unit>]

  limit rate      <number>/{second,minute,hour,day,week} burst <number> packets accept
  limit rate over <number>/{second,minute,hour,day,week} burst <number> packets drop

  limit rate      <number> {bytes,kbytes,mbytes}/{second,minute,hour,day,week} burst <number> {bytes,kbytes,mbytes} accept
  limit rate over <number> {bytes,kbytes,mbytes}/{second,minute,hour,day,week} burst <number> {bytes,kbytes,mbytes} drop

  * tcp dport 80 limit rate 1000 kbytes/second burst 2000 kbytes } accept # per service
  * tcp dport 80 meter ratelimit { ip saddr limit rate 100 kbytes/second burst 200 kbytes } accept # per user on service

#############

# mixed meters

 static match { dynamic match }

 nft list meters
 nft list meter <type> <table> <name>

 ct state established meter outbound_user_udp { skuid . udp dport counter }
 ct state established meter outbound_user_tcp { skuid . tcp dport counter }
 meter usercounter4 { skuid . ip  daddr counter }
 meter usercounter6 { skuid . ip6 daddr counter }
 ip protocol udp ct state established meter ipudp  { ip saddr . udp dport counter } accept
 ip protocol tcp ct state established meter iptcp  { ip saddr . tcp dport counter } accept
 ip6 nexthdr udp ct state established meter ip6udp { ip6 saddr . udp dport counter } accept
 ip6 nexthdr tcp ct state established meter ip6tcp { ip6 saddr . tcp dport counter } accept

#############

 ^ other than connlimit and ratelimit meters dont do alot other than cummulative logs ?

#############

#############
table bridge filter { chain forward { type filter hook forward priority 0 ; policy drop ; } ; } # prevent guests on a bridge from communicating
#############

 networking support
 networking options
 network packet filtering framework
 core netfilter configuration
 nf_tables stateful object reference model
 CONFIG_NFT_OBJREF

 statefull objects
  counters
  quotas
  limits
  connlimits

 ^ allows creating in the table
   and refering to the object multiple times

 * currently disabled never had any need for it ?

#############
=============
# [mangle] - never needed it ?
=============
 set - used to change a match without conntrack recording ?
       breaks everything quiet easily
=============
 table inet filter {
  chain prerouting {
   type filter hook prerouting priority 0 ; policy accept ;
   udp dport 53 udp dport set 5353
   udp sport 5353 udp sport set 53
  }
 }
=============
#############

